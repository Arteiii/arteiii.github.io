"use strict";(self.webpackChunkarteiii_github_io=self.webpackChunkarteiii_github_io||[]).push([[623],{900:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>r,contentTitle:()=>a,default:()=>p,frontMatter:()=>l,metadata:()=>o,toc:()=>u});var s=t(4848),i=t(8453);const l={id:"tuples",title:"Tuples",sidebar_position:1,description:"(i32, bool)"},a=void 0,o={id:"datatypes/primitives/compound/tuples",title:"Tuples",description:"(i32, bool)",source:"@site/rust-cookbook/datatypes/primitives/compound/tuples.md",sourceDirName:"datatypes/primitives/compound",slug:"/datatypes/primitives/compound/tuples",permalink:"/rust-cookbook/datatypes/primitives/compound/tuples",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:1,frontMatter:{id:"tuples",title:"Tuples",sidebar_position:1,description:"(i32, bool)"},sidebar:"rustCookbookSidebar",previous:{title:"Compound",permalink:"/rust-cookbook/datatypes/primitives/compound/"},next:{title:"Standard Library",permalink:"/rust-cookbook/datatypes/standard-library/"}},r={},u=[{value:"Tuples in Rust: Compact, Versatile, and Type-Safe Groupings",id:"tuples-in-rust-compact-versatile-and-type-safe-groupings",level:2},{value:"Creating and Using Tuples",id:"creating-and-using-tuples",level:3},{value:"Accessing Tuple Elements",id:"accessing-tuple-elements",level:3},{value:"Common Uses of Tuples",id:"common-uses-of-tuples",level:3},{value:"Tuple Size and Homogeneity",id:"tuple-size-and-homogeneity",level:3},{value:"Example: Swapping Values",id:"example-swapping-values",level:3}];function d(e){const n={code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h2,{id:"tuples-in-rust-compact-versatile-and-type-safe-groupings",children:"Tuples in Rust: Compact, Versatile, and Type-Safe Groupings"}),"\n",(0,s.jsx)(n.p,{children:"In Rust, a tuple is a collection of values of different types grouped together into a single compound type. It\u2019s handy\nwhen you want to return multiple values from a function or group data that does not necessarily belong together in a\nnamed structure like a struct."}),"\n",(0,s.jsx)(n.h3,{id:"creating-and-using-tuples",children:"Creating and Using Tuples"}),"\n",(0,s.jsx)(n.p,{children:"Tuples are defined using parentheses, and the values are separated by commas. They can store a variety of data types,\nand their size is fixed at compile time."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'let tuple: (i32, f64, &str) = (42, 3.14, "hello");\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Here, ",(0,s.jsx)(n.code,{children:"tuple"})," holds three elements of different types: an ",(0,s.jsx)(n.code,{children:"i32"}),", an ",(0,s.jsx)(n.code,{children:"f64"}),", and a string slice (",(0,s.jsx)(n.code,{children:"&str"}),")."]}),"\n",(0,s.jsx)(n.h3,{id:"accessing-tuple-elements",children:"Accessing Tuple Elements"}),"\n",(0,s.jsx)(n.p,{children:"You can access the elements of a tuple using dot notation followed by the index of the element (starting at 0)."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'let first = tuple.0; // 42\nlet second = tuple.1; // 3.14\nlet third = tuple.2; // "hello"\n'})}),"\n",(0,s.jsx)(n.p,{children:"If you want to destructure a tuple into individual variables, you can use pattern matching:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"let (x, y, z) = tuple;\n"})}),"\n",(0,s.jsxs)(n.p,{children:["This assigns ",(0,s.jsx)(n.code,{children:"x = 42"}),", ",(0,s.jsx)(n.code,{children:"y = 3.14"}),", and ",(0,s.jsx)(n.code,{children:'z = "hello"'}),"."]}),"\n",(0,s.jsx)(n.h3,{id:"common-uses-of-tuples",children:"Common Uses of Tuples"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Returning Multiple Values from Functions"}),": Since Rust doesn\u2019t have built-in support for multiple return values,\ntuples can simulate that functionality:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"fn split_point() -> (i32, i32) {\n    (10, 20)\n}\nlet (x, y) = split_point(); // x = 10, y = 20\n"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Grouping Data"}),": Tuples are often used when you need to group data temporarily, without defining a dedicated\nstruct."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"let point = (3, 4);\nlet distance = (point.0.pow(2) + point.1.pow(2)).sqrt();\n"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Pairing Iterators"}),": Tuples are useful in iterators or maps, where you may want to process data as ",(0,s.jsx)(n.code,{children:"(key, value)"}),"\npairs."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"tuple-size-and-homogeneity",children:"Tuple Size and Homogeneity"}),"\n",(0,s.jsxs)(n.p,{children:["While tuples can mix different types, their size is fixed and cannot be changed after initialization. Rust enforces type\nsafety by ensuring that the tuple type matches its structure. For example, ",(0,s.jsx)(n.code,{children:"(i32, i32)"})," is distinct from ",(0,s.jsx)(n.code,{children:"(i32, f64)"}),"."]}),"\n",(0,s.jsx)(n.h3,{id:"example-swapping-values",children:"Example: Swapping Values"}),"\n",(0,s.jsx)(n.p,{children:"One quick trick with tuples is using them to swap values in place without a temporary variable:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"let mut a = 5;\nlet mut b = 10;\n(a, b) = (b, a); // Now a = 10, b = 5\n"})})]})}function p(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>o});var s=t(6540);const i={},l=s.createContext(i);function a(e){const n=s.useContext(l);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),s.createElement(l.Provider,{value:n},e.children)}}}]);