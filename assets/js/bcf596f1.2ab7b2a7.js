"use strict";(self.webpackChunkarteiii_github_io=self.webpackChunkarteiii_github_io||[]).push([[8587],{9011:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>d,default:()=>h,frontMatter:()=>r,metadata:()=>l,toc:()=>o});var s=i(4848),t=i(8453);const r={id:"integers",title:"Integers",sidebar_position:1,description:"i8, i16, i32, i64, i128, isize, u8, u16, u32, u64, u128, usize"},d=void 0,l={id:"datatypes/primitives/scalar/integers",title:"Integers",description:"i8, i16, i32, i64, i128, isize, u8, u16, u32, u64, u128, usize",source:"@site/rust-cookbook/datatypes/primitives/scalar/integers.md",sourceDirName:"datatypes/primitives/scalar",slug:"/datatypes/primitives/scalar/integers",permalink:"/rust-cookbook/datatypes/primitives/scalar/integers",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:1,frontMatter:{id:"integers",title:"Integers",sidebar_position:1,description:"i8, i16, i32, i64, i128, isize, u8, u16, u32, u64, u128, usize"},sidebar:"rustCookbookSidebar",previous:{title:"Scalar",permalink:"/rust-cookbook/datatypes/primitives/scalar/"},next:{title:"Booleans",permalink:"/rust-cookbook/datatypes/primitives/scalar/booleans"}},c={},o=[{value:"Signed vs. Unsigned Integers",id:"signed-vs-unsigned-integers",level:4},{value:"Integer Types and Their Sizes",id:"integer-types-and-their-sizes",level:4},{value:"Creating and Using Integers",id:"creating-and-using-integers",level:4},{value:"Arithmetic Operations",id:"arithmetic-operations",level:4},{value:"Overflow Handling",id:"overflow-handling",level:4},{value:"Conversion Between Integer Types",id:"conversion-between-integer-types",level:4},{value:"Common Methods",id:"common-methods",level:4},{value:"Example: Handling Overflow Explicitly",id:"example-handling-overflow-explicitly",level:4}];function a(e){const n={code:"code",h4:"h4",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:"In Rust, integers are primitive types used to represent whole numbers.\nThey come in both signed and unsigned varieties,\nwith different sizes available for optimal performance or specific use cases.\nRust provides multiple integer types with different ranges, ensuring type safety and efficient memory use."}),"\n",(0,s.jsx)(n.h4,{id:"signed-vs-unsigned-integers",children:"Signed vs. Unsigned Integers"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Signed integers"})," (",(0,s.jsx)(n.code,{children:"i"}),") can store both positive and negative numbers.\nThe sign takes one bit, so the range of values is reduced compared to unsigned integers of the same size."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Unsigned integers"})," (",(0,s.jsx)(n.code,{children:"u"}),") can store only non-negative numbers,\nallowing them to represent a larger range of positive numbers than their signed counterparts."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"integer-types-and-their-sizes",children:"Integer Types and Their Sizes"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Type"}),(0,s.jsx)(n.th,{children:"Size"}),(0,s.jsx)(n.th,{children:"Range"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"i8"})}),(0,s.jsx)(n.td,{children:"8-bit"}),(0,s.jsx)(n.td,{children:"-128 to 127"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"u8"})}),(0,s.jsx)(n.td,{children:"8-bit"}),(0,s.jsx)(n.td,{children:"0 to 255"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"i16"})}),(0,s.jsx)(n.td,{children:"16-bit"}),(0,s.jsx)(n.td,{children:"-32,768 to 32,767"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"u16"})}),(0,s.jsx)(n.td,{children:"16-bit"}),(0,s.jsx)(n.td,{children:"0 to 65,535"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"i32"})}),(0,s.jsx)(n.td,{children:"32-bit"}),(0,s.jsx)(n.td,{children:"-2,147,483,648 to 2,147,483,647"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"u32"})}),(0,s.jsx)(n.td,{children:"32-bit"}),(0,s.jsx)(n.td,{children:"0 to 4,294,967,295"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"i64"})}),(0,s.jsx)(n.td,{children:"64-bit"}),(0,s.jsx)(n.td,{children:"-9,223,372,036,854,775,808 to 9,223,372,036,854,775,807"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"u64"})}),(0,s.jsx)(n.td,{children:"64-bit"}),(0,s.jsx)(n.td,{children:"0 to 18,446,744,073,709,551,615"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"i128"})}),(0,s.jsx)(n.td,{children:"128-bit"}),(0,s.jsx)(n.td,{children:"Huge range"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"u128"})}),(0,s.jsx)(n.td,{children:"128-bit"}),(0,s.jsx)(n.td,{children:"Huge range"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"isize"})}),(0,s.jsx)(n.td,{children:"Architecture-dependent"}),(0,s.jsx)(n.td,{children:"Varies based on CPU architecture (32 or 64-bit)"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"usize"})}),(0,s.jsx)(n.td,{children:"Architecture-dependent"}),(0,s.jsx)(n.td,{children:"Varies based on CPU architecture (32 or 64-bit)"})]})]})]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"isize"})," and ",(0,s.jsx)(n.code,{children:"usize"})," types depend on the system\u2019s architecture.\nOn a 32-bit system, they are 32 bits wide, and on a 64-bit system, they are 64 bits wide.\nThese are commonly used when indexing collections or working with memory addresses."]}),"\n",(0,s.jsx)(n.h4,{id:"creating-and-using-integers",children:"Creating and Using Integers"}),"\n",(0,s.jsxs)(n.p,{children:["You can create integers using literals. By default, Rust infers ",(0,s.jsx)(n.code,{children:"i32"})," if no specific type is provided."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"let signed: i32 = -42;\nlet unsigned: u32 = 42;\n"})}),"\n",(0,s.jsx)(n.p,{children:"You can specify integer literals using suffixes:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"let small = 120i8;\nlet large: u64 = 1_000_000;\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Note: The ",(0,s.jsx)(n.code,{children:"_"})," is used for readability and does not affect the value."]}),"\n",(0,s.jsx)(n.h4,{id:"arithmetic-operations",children:"Arithmetic Operations"}),"\n",(0,s.jsxs)(n.p,{children:["Rust supports standard arithmetic operations on integers,\nincluding addition (",(0,s.jsx)(n.code,{children:"+"}),"), subtraction (",(0,s.jsx)(n.code,{children:"-"}),"), multiplication (",(0,s.jsx)(n.code,{children:"*"}),"), division (",(0,s.jsx)(n.code,{children:"/"}),"), and modulus (",(0,s.jsx)(n.code,{children:"%"}),"):"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"let sum = 5 + 10;\nlet product = 4 * 6;\nlet quotient = 10 / 2;\nlet remainder = 10 % 3;\n"})}),"\n",(0,s.jsx)(n.h4,{id:"overflow-handling",children:"Overflow Handling"}),"\n",(0,s.jsx)(n.p,{children:"By default, Rust checks for overflow in debug mode.\nFor example, if you try to assign a value that exceeds the range of the integer type, it will panic in debug mode."}),"\n",(0,s.jsxs)(n.p,{children:["In release mode, Rust allows overflow with wrapping behavior (modulo behavior).\nYou can also use methods like ",(0,s.jsx)(n.code,{children:".wrapping_add()"}),", ",(0,s.jsx)(n.code,{children:".checked_add()"}),", ",(0,s.jsx)(n.code,{children:".saturating_add()"}),",\nand ",(0,s.jsx)(n.code,{children:".overflowing_add()"})," to handle overflows explicitly."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"let result = 255u8.wrapping_add(1); // Wraps to 0\n"})}),"\n",(0,s.jsx)(n.h4,{id:"conversion-between-integer-types",children:"Conversion Between Integer Types"}),"\n",(0,s.jsxs)(n.p,{children:["If you need to convert between integer types, you can use ",(0,s.jsx)(n.code,{children:"as"})," for casting:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"let small: u8 = 100;\nlet large: u32 = small as u32;\n"})}),"\n",(0,s.jsx)(n.p,{children:"Rust will not automatically convert between different integer types to ensure type safety."}),"\n",(0,s.jsx)(n.h4,{id:"common-methods",children:"Common Methods"}),"\n",(0,s.jsx)(n.p,{children:"Rust\u2019s integer types come with useful methods:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Checking even/odd"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'let num: i32 = 4;\nprintln!("{}", num.is_even()); // true\nprintln!("{}", num.is_odd());  // false\n'})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Converting to/from Strings"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'let num_str = 42.to_string();\nlet parsed_num: i32 = "42".parse().unwrap();\n'})}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"example-handling-overflow-explicitly",children:"Example: Handling Overflow Explicitly"}),"\n",(0,s.jsxs)(n.p,{children:["Let\u2019s say you want to safely add two ",(0,s.jsx)(n.code,{children:"u8"})," values without panicking or wrapping:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'fn safe_add(a: u8, b: u8) -> Option<u8> {\n    a.checked_add(b)\n}\n\nlet result = safe_add(250, 10);\nprintln!("{:?}", result); // None (would overflow)\n'})})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(a,{...e})}):a(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>d,x:()=>l});var s=i(6540);const t={},r=s.createContext(t);function d(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:d(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);