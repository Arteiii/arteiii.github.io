"use strict";(self.webpackChunkarteiii_github_io=self.webpackChunkarteiii_github_io||[]).push([[7935],{97:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>r,contentTitle:()=>l,default:()=>d,frontMatter:()=>i,metadata:()=>c,toc:()=>p});var t=o(4848),s=o(8453);const i={sidebar_position:11},l="Shallow & Deep Copy",c={id:"python/shallow_deep",title:"Shallow & Deep Copy",description:"x and y are assigned to the same object(3)",source:"@site/docs/python/shallow_deep.md",sourceDirName:"python",slug:"/python/shallow_deep",permalink:"/docs/python/shallow_deep",draft:!1,unlisted:!1,editUrl:"https://github.com/arteiii/arteiii.github.io/tree/main/docs/python/shallow_deep.md",tags:[],version:"current",sidebarPosition:11,frontMatter:{sidebar_position:11},sidebar:"docsSidebar",previous:{title:"Formated Output",permalink:"/docs/python/formated_output"},next:{title:"Functions",permalink:"/docs/python/functions"}},r={},p=[{value:"Shallow Copy",id:"shallow-copy",level:2},{value:"Deep Copy",id:"deep-copy",level:2},{value:"Deep Copy Dictionaries",id:"deep-copy-dictionaries",level:2},{value:"Copy Lists",id:"copy-lists",level:2}];function a(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"shallow--deep-copy",children:"Shallow & Deep Copy"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-py",children:">>> x = 3\n>>> y = 3\n"})}),"\n",(0,t.jsx)(n.p,{children:"x and y are assigned to the same object(3)\nthe proof that this is really so can be provided with the help of the id-function:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-py",children:">>> print(id(x), id(y))\n10861256 10861256\n"})}),"\n",(0,t.jsx)(n.p,{children:"so what happens if we assign a different value to one variable"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-py",children:">>> y = 2\n>>> print(id(x) == id(y), x, y)\nFalse 3 2\n"})}),"\n",(0,t.jsx)(n.p,{children:"y now points to an integer object of its own"}),"\n",(0,t.jsx)(n.h2,{id:"shallow-copy",children:"Shallow Copy"}),"\n",(0,t.jsx)(n.p,{children:"the copy-method can be used to create flat copies of lists"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-py",children:">>> list1 = [\"3\", \"6\", \"9\"]\n>>> list2 = list1.copy()\n>>> list2[1] = \"x\"\n>>> print(list1)\n['3', '6', '9']\n\n>>> print(list2)\n['3', 'x', '9']\n"})}),"\n",(0,t.jsx)("br",{}),"\n",(0,t.jsx)(n.p,{children:"but as soon as there are sublists in the list to be copied,"}),"\n",(0,t.jsx)("br",{}),"\n",(0,t.jsx)(n.p,{children:"only pointers to these sublists are copied"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-py",children:'>>> lst1 = ["a", "b",["cd", "dc"]]\n>>> lst2 = lst1.copy()\n>>> lst2[0] = "c"\n>>> lst2[2][0] = "f"\n>>> print(lst1)\n[\'a\', \'b\', [\'f\', \'dc\']]\n'})}),"\n",(0,t.jsx)(n.h2,{id:"deep-copy",children:"Deep Copy"}),"\n",(0,t.jsx)(n.p,{children:"one solution for the problem just described is the module copy\nwhich provides the deepcopy function"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-py",children:">>> from copy import deepcopy\n>>> lst1 = [\"a\", \"b\",[\"cd\", \"dc\"]]\n>>> lst2 = deepcopy(lst1)\n\n\n>>> lst2[2][1] = \"d\"\n>>> lst2[0] = \"c\"\n>>> print(lst2)\n['c', 'b', ['cd', 'd']]\n\n>>> print(lst1)\n['a', 'b', ['cd', 'dc']]\n"})}),"\n",(0,t.jsx)(n.h2,{id:"deep-copy-dictionaries",children:"Deep Copy Dictionaries"}),"\n",(0,t.jsx)(n.p,{children:"deepcopy from the module copy works for any python object\nfrom copy import deepcopy"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-py",children:">>> d = {\"a\": 3, \"b\": 4}\n>>> copy_of_d = deepcopy(d)\n>>> d[\"c\"] = 1\n>>> d\n{'a': 3, 'b': 4, 'c': 1}\n>>> copy_of_d\n{'a': 3, 'b': 4}\n"})}),"\n",(0,t.jsx)(n.p,{children:"also the method copy creates only a flat copy"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-py",children:'>>> p = {"John": {"weight": 87.8, "Height": 187.5}}\n>>> p = {"John": {"weight": 87.8, "Height": 187.5},"Jane":\n  {"weight": 60.6, "height": 168.4}}\n>>> p2 = p.copy()\n>>> p["Jane"]["weight"] -= 0.4\n>>> p2\n{\'John\': {\'weight\': 87.8, \'Height\': 187.5},\n \'Jane\': {\'weight\': 60.2, \'height\': 168.4}}\n\n>>> p2 = deepcopy(p)\n>>> p["Jane"]["weight"] -= 0.2\n>>> p2["Jane"]["weight"]\n60.0\n\n>>> p["Jane"]["weight"]\n59.8\n'})}),"\n",(0,t.jsx)(n.h2,{id:"copy-lists",children:"Copy Lists"}),"\n",(0,t.jsx)(n.p,{children:"in this example we create a flat copy of a list"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-py",children:">>> colors1 = [\"red\", \"blue\"]\n>>> colors2 = colors1\n>>> print(colors1)\n['red', 'blue']\n\n>>> print(colors2)\n['red', 'blue']\n\n>>> print(id(colors1), id(colors2))\n140535031048896 140535031048896\n\n>>> colors1 = [\"blue\", \"yellow\"]\n>>> print(colors1)\n['blue', 'yellow']\n\n>>> print(colors2)\n['red', 'blue']\n\n>>> colors1 = [\"red\", \"blue\"]\n>>> colors2 = colors1\n>>> colors2[1] = \"green\"\n>>> print(colors1)\n['red', 'green']\n\n>>> print(colors2)\n['red', 'green']\n"})}),"\n",(0,t.jsx)(n.p,{children:"as we have already seen, in the assignment colors1 = colors2\nonly one reference to the same list is created\nso changes within the list object apply to colors1 and colors2\nsince they point to the same object"})]})}function d(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(a,{...e})}):a(e)}},8453:(e,n,o)=>{o.d(n,{R:()=>l,x:()=>c});var t=o(6540);const s={},i=t.createContext(s);function l(e){const n=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:l(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);