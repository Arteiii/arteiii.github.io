"use strict";(self.webpackChunkarteiii_github_io=self.webpackChunkarteiii_github_io||[]).push([[8958],{2686:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>i,default:()=>h,frontMatter:()=>t,metadata:()=>o,toc:()=>l});var a=s(4848),r=s(8453);const t={id:"broadcast",title:"Broadcast",sidebar_position:1,description:"broadcast"},i="Broadcast Data Type in Tokio",o={id:"tokio/sync/broadcast",title:"Broadcast",description:"broadcast",source:"@site/rust-cookbook/tokio/sync/broadcast.md",sourceDirName:"tokio/sync",slug:"/tokio/sync/broadcast",permalink:"/rust-cookbook/tokio/sync/broadcast",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:1,frontMatter:{id:"broadcast",title:"Broadcast",sidebar_position:1,description:"broadcast"},sidebar:"rustCookbookSidebar",previous:{title:"Sync",permalink:"/rust-cookbook/tokio/sync/"},next:{title:"Database",permalink:"/rust-cookbook/database/"}},c={},l=[{value:"What is a Broadcast Channel?",id:"what-is-a-broadcast-channel",level:2},{value:"Basic Usage",id:"basic-usage",level:2},{value:"Creating a Broadcast Channel",id:"creating-a-broadcast-channel",level:3},{value:"Sending Messages",id:"sending-messages",level:3},{value:"Receiving Messages",id:"receiving-messages",level:3},{value:"Handling Message Drops",id:"handling-message-drops",level:3},{value:"Unique Features of the Tokio Broadcast Channel",id:"unique-features-of-the-tokio-broadcast-channel",level:2},{value:"Practical Use Cases",id:"practical-use-cases",level:2}];function d(e){const n={admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"broadcast-data-type-in-tokio",children:"Broadcast Data Type in Tokio"})}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"broadcast"})," channel in Tokio is a powerful mechanism used to send data to multiple consumers simultaneously.\nIt is especially useful in scenarios where you need to send the same message to multiple tasks or processes concurrently\nwithout worrying about managing each consumer independently."]}),"\n",(0,a.jsx)(n.h2,{id:"what-is-a-broadcast-channel",children:"What is a Broadcast Channel?"}),"\n",(0,a.jsxs)(n.p,{children:["A ",(0,a.jsx)(n.code,{children:"broadcast"})," channel is a multi-producer,\nmulti-consumer channel that ensures all active consumers receive each message sent to the channel.\nUnlike other channels, such as ",(0,a.jsx)(n.code,{children:"mpsc"})," (multi-producer, single-consumer),\nthe broadcast channel guarantees that every consumer gets a copy of the message,\neven if multiple consumers are listening."]}),"\n",(0,a.jsx)(n.p,{children:"Key properties:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Broadcasting"}),": Every message sent is delivered to all current receivers."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Bounded capacity"}),": The broadcast channel has a bounded capacity,\nand if it exceeds this limit, older messages are dropped."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Message cloning"}),": Messages must implement the ",(0,a.jsx)(n.code,{children:"Clone"})," trait because they are duplicated for each receiver."]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"basic-usage",children:"Basic Usage"}),"\n",(0,a.jsx)(n.h3,{id:"creating-a-broadcast-channel",children:"Creating a Broadcast Channel"}),"\n",(0,a.jsxs)(n.p,{children:["To create a broadcast channel, you use the ",(0,a.jsx)(n.code,{children:"broadcast::channel"})," function, which takes a capacity argument.\nThis argument defines the number of messages the channel can hold before old messages are discarded."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:"use tokio::sync::broadcast;\n\n#[tokio::main]\nasync fn main() {\n    let (tx, _rx) = broadcast::channel(10);\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"In this example, the channel can hold up to 10 messages at a time.\nWhen the buffer is full, the oldest messages are dropped to make room for new ones."}),"\n",(0,a.jsx)(n.h3,{id:"sending-messages",children:"Sending Messages"}),"\n",(0,a.jsxs)(n.p,{children:["To send a message to all consumers, you call the ",(0,a.jsx)(n.code,{children:"send"})," method on the transmitter (",(0,a.jsx)(n.code,{children:"tx"}),")."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:"use tokio::sync::broadcast;\n\n#[tokio::main]\nasync fn main() {\n    let (tx, _rx) = broadcast::channel(10);\n\n    // Send a message to all consumers\n    tx.send(42).unwrap();\n}\n"})}),"\n",(0,a.jsx)(n.admonition,{type:"info",children:(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"send"})," function returns a ",(0,a.jsx)(n.code,{children:"Result"})," indicating whether the message was sent successfully.\nIt returns an error if no receivers are listening."]})}),"\n",(0,a.jsx)(n.h3,{id:"receiving-messages",children:"Receiving Messages"}),"\n",(0,a.jsxs)(n.p,{children:["To receive messages, each consumer spawns a receiver (",(0,a.jsx)(n.code,{children:"rx"}),").\nYou can clone the receiver to create multiple consumers."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:'use tokio::sync::broadcast;\nuse tokio::task;\n\n#[tokio::main]\nasync fn main() {\n    let (tx, rx1) = broadcast::channel(10);\n    let mut rx2 = tx.subscribe();  // Create a second receiver\n\n    // Task 1: Receive messages\n    task::spawn(async move {\n        while let Ok(message) = rx1.recv().await {\n            println!("Receiver 1 got: {}", message);\n        }\n    });\n\n    // Task 2: Receive messages\n    task::spawn(async move {\n        while let Ok(message) = rx2.recv().await {\n            println!("Receiver 2 got: {}", message);\n        }\n    });\n\n    // Send a message\n    tx.send(42).unwrap();\n}\n'})}),"\n",(0,a.jsx)(n.h3,{id:"handling-message-drops",children:"Handling Message Drops"}),"\n",(0,a.jsxs)(n.p,{children:["Since the broadcast channel has a bounded capacity, if a receiver falls behind, it may miss some messages.\nIn that case, the ",(0,a.jsx)(n.code,{children:"recv"})," function will return an error of type ",(0,a.jsx)(n.code,{children:"RecvError::Lagged"}),",\nwhich tells how many messages were missed."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:'use tokio::sync::broadcast;\n\n#[tokio::main]\nasync fn main() {\n    let (tx, mut rx) = broadcast::channel(2);\n\n    tx.send(1).unwrap();\n    tx.send(2).unwrap();\n    tx.send(3).unwrap();  // This will cause a message drop for any slow receiver\n\n    match rx.recv().await {\n        Ok(message) => println!("Received: {}", message),\n        Err(broadcast::error::RecvError::Lagged(n)) => {\n            println!("Missed {} messages", n);\n        }\n        Err(_) => println!("Receiver closed"),\n    }\n}\n'})}),"\n",(0,a.jsx)(n.h2,{id:"unique-features-of-the-tokio-broadcast-channel",children:"Unique Features of the Tokio Broadcast Channel"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Multi-consumer support"}),": Unlike ",(0,a.jsx)(n.code,{children:"mpsc"}),", ",(0,a.jsx)(n.code,{children:"broadcast"})," supports multiple consumers listening to the same channel.\nEach receiver gets its own copy of the message, allowing concurrent tasks to process the same data independently."]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Bounded channel with backpressure"}),": The bounded nature of the broadcast channel introduces backpressure. When the\nbuffer is full, older messages are dropped, ensuring that the channel remains responsive even under load. This is\nuseful for real-time systems where older messages may no longer be relevant."]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Cloneable receivers"}),": You can create multiple receivers from a single transmitter using the ",(0,a.jsx)(n.code,{children:"subscribe"})," method.\nEach receiver operates independently, meaning each can receive messages at its own pace."]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Message drops and error handling"}),": The channel provides useful error information when messages are dropped due to\nslow receivers. This allows you to handle the lagged state appropriately in your application."]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Real-time data distribution"}),": The broadcast channel is ideal for real-time use cases such as live data feeds,\nlogging, or event broadcasting, where you want multiple tasks to react to the same set of events."]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Zero-copy transmission"}),": Because the broadcast channel requires messages to implement ",(0,a.jsx)(n.code,{children:"Clone"}),", it allows for\nefficient duplication of data across receivers without modifying the original message."]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"practical-use-cases",children:"Practical Use Cases"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Logging"}),": You can broadcast log messages to multiple consumers (e.g., different log processing tasks)."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Live data feeds"}),": Ideal for applications where multiple tasks need to consume the same stream of data, such as in\nfinancial or monitoring systems."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Notification systems"}),": You can notify multiple parts of your system about state changes or events simultaneously."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Real-time web applications"}),": Integrating with WebSocket servers to send updates to multiple connected clients at\nonce."]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>i,x:()=>o});var a=s(6540);const r={},t=a.createContext(r);function i(e){const n=a.useContext(t);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),a.createElement(t.Provider,{value:n},e.children)}}}]);